# 可选的异步网络请求库
_Exported on 2025/6/20 at GMT+8 13:10:17 from Cursor (1.1.4)_

---

**User**

可以集成到 php 7 甚至更低版本的 异步网络请求和文件 io 库，最好是  composer 标准库的可选技术方案有哪些？

---

**Cursor**

好的，很高兴为您提供适用于 PHP 7 及更低版本的异步网络请求和文件 I/O 库的技术方案选项。这些库大多可以通过 Composer 进行管理。

对于这个需求，主要有几大类成熟的解决方案：

### 1. GuzzleHttp (HTTP 客户端)

Guzzle 是一个非常流行和强大的 PHP HTTP 客户端，它可以轻松地发送同步和异步请求。对于仅需要异步网络请求的场景，这是一个非常好的选择。

*   **核心特性**:
    *   通过 Promises 实现异步请求，可以并发执行多个请求。
    *   构建在 PHP 的 cURL 扩展之上，性能可靠。
    *   拥有丰富的中间件生态系统，可以添加缓存、重试、日志等功能。
    *   接口友好，文档齐全。
*   **PHP 版本兼容性**:
    *   `Guzzle 6.x` 版本可以很好地支持 `PHP 5.5+`，包括 PHP 7 的所有版本。如果你需要兼容非常旧的 PHP 环境，这是一个理想的选择。
    *   `Guzzle 7.x` 版本要求 `PHP 7.2.5+`。
*   **文件 I/O**:
    *   Guzzle 本身不直接提供异步文件 I/O 功能，它专注于 HTTP 请求。如果需要异步文件操作，需要结合下面介绍的库。

**适用场景**: 主要需要处理异步 HTTP API 调用，而对本地文件 I/O 的异步需求不高的项目。

### 2. ReactPHP (事件驱动框架)

ReactPHP 是一个用于 PHP 的事件驱动、非阻塞 I/O 的底层库。它提供了一个事件循环（Event Loop），并围绕它构建了网络、流、文件系统等异步操作的生态系统。

*   **核心特性**:
    *   提供了核心的事件循环，是其他组件的基础。
    *   组件化设计：包括 HTTP 客户端/服务端、DNS、缓存、子进程、文件系统等。
    *   完全用 PHP 实现，不需要安装额外的扩展。
    *   非常适合构建需要长时间运行、处理大量并发连接的应用程序，如网络服务、聊天应用等。
*   **PHP 版本兼容性**:
    *   ReactPHP 的组件有不同的版本要求，但其核心组件和许多早期版本都支持 `PHP 5.3` 及以上版本，对 PHP 7 有完美的支持。您可以根据项目具体的 PHP 版本选择合适的组件版本。
*   **文件 I/O**:
    *   它有一个 `react/filesystem` 组件，可以提供异步文件系统操作。

**适用场景**: 需要同时处理异步网络和文件 I/O，或构建复杂的事件驱动应用程序。

### 3. Amp (并发框架)

Amp 是另一个流行的 PHP 异步编程框架。它使用 Promises 和 Coroutines (通过 PHP 的 `yield` 关键字) 来简化异步代码的编写，使其看起来更像是同步代码。

*   **核心特性**:
    *   同样提供了事件循环作为核心。
    *   通过 `amphp/` 组织下的一系列包提供功能，如 `amphp/http-client`, `amphp/file`, `amphp/socket` 等。
    *   使用协程（Coroutines）可以让异步代码更易读、易维护。
    *   和 ReactPHP 一样，它也是纯 PHP 实现。
*   **PHP 版本兼容性**:
    *   `Amp v2.x` 要求 `PHP 7.0+`。
    *   更早的 `Amp v1.x` 版本支持 `PHP 5.5+`。
*   **文件 I/O**:
    *   提供了 `amphp/file` 包来处理异步文件读写。

**适用场景**: 与 ReactPHP 类似，但其协程的编程模型可能对某些开发者更具吸引力。

### 4. Swoole / OpenSwoole (PHP 扩展)

Swoole 是一个通过 PECL 安装的 PHP 扩展，它为 PHP 提供了高性能的异步、并行和并发处理能力。它不是一个纯粹的 Composer 库，而是一个底层的引擎。

*   **核心特性**:
    *   性能极高，接近 Go/Node.js 的性能水平。
    *   内置了协程（Coroutine）支持，并且提供了“一键协程化”功能，可以将同步的 I/O 代码（如 `file_get_contents`, `mysqli`, `redis` 等）自动转换为异步的。
    *   内置了 HTTP/WebSocket/TCP/UDP 服务器，无需依赖 Nginx 或 Apache。
    *   功能强大，支持进程管理、定时器、通道（Channel）等高级特性。
*   **PHP 版本兼容性**:
    *   Swoole 的不同版本对 PHP 的要求不同。例如 `Swoole 4.x` 系列广泛支持 `PHP 7.2+`。你需要查找与你的 PHP 版本兼容的 Swoole 版本。
    *   `OpenSwoole` 是 Swoole 的一个分支，也在持续发展。
*   **缺点**:
    *   需要服务器管理员权限来安装 PECL 扩展，这在共享主机等受限环境中可能不可行。
    *   学习曲线相对陡峭。

**适用场景**: 对性能有极致要求的项目，如高并发 API 网关、游戏服务器、实时通讯服务等。

### 技术选型建议

| 方案 | 优点 | 缺点 | 推荐场景 |
| :--- | :--- | :--- | :--- |
| **GuzzleHttp** | 简单易用，文档丰富，专注于 HTTP | 不提供异步文件 I/O | 只需要异步调用外部 API |
| **ReactPHP** | 纯 PHP 实现，生态完善，支持旧版 PHP | 编码风格（回调地狱）可能较复杂 | 需要构建复杂的、长时运行的异步应用 |
| **Amp** | 纯 PHP 实现，协程让代码更优雅 | 生态相对 ReactPHP 可能稍小 | 喜欢协程编程模型，构建复杂异步应用 |
| **Swoole** | 性能最高，功能最强大 | 需要安装扩展，有环境限制，学习成本高 | 高性能、高并发的后端服务 |

如果您的项目**主要需求是加快对外部 API 的请求速度**，并且希望改动尽可能小，**Guzzle 是最简单、最直接的选择**。

如果您的项目需要**全面的异步能力（网络、文件、数据库等）**，并且不希望或不能安装 PHP 扩展，那么 **ReactPHP** 或 **Amp** 是非常好的选择。它们之间的选择更多是基于个人对编程风格（回调 vs 协程）的偏好。

希望这些信息能帮助您做出决策！如果您有更具体的需求，我很乐意提供进一步的分析。

---

**User**

GuzzleHttp  异步和并发是如何实现的？

---

**Cursor**

当然可以。GuzzleHttp 的异步和并发实现是一个非常优雅的设计，它主要依赖于 **Promises (承诺)** 和 **Handlers (处理器)** 这两个核心概念，并且在底层巧妙地利用了 PHP 的 cURL 扩展功能。

让我们来分解一下它的实现机制。

### 1. 核心概念：Promises (承诺)

这是理解 Guzzle 异步的关键。一个 **Promise** 是一个对象，它代表一个**未来才会完成的操作**的结果。可以把它想象成一张“提货单”：

*   你调用一个异步方法（比如 `requestAsync`），你不会立即拿到 HTTP 响应，而是立即拿到一张“提货单”（Promise 对象）。
*   这张提货单有一个状态：
    *   **Pending (待定)**：操作还没完成，你还在等待。
    *   **Fulfilled (已实现)**：操作成功完成，你可以凭提货单拿到你的货物（HTTP Response）。
    *   **Rejected (已拒绝)**：操作失败，提货单上会写明失败的原因（一个 Exception）。

你可以通过 Promise 的 `.then()` 方法来注册回调函数，这些函数会在 Promise 状态变为 Fulfilled 或 Rejected 时被执行。

```php
$promise = $client->requestAsync('GET', 'http://example.com');

$promise->then(
    function ($response) {
        // 请求成功时执行 (Fulfilled)
        echo 'Success! ' . $response->getStatusCode();
    },
    function ($exception) {
        // 请求失败时执行 (Rejected)
        echo 'Error! ' . $exception->getMessage();
    }
);
```

**关键点**：调用 `requestAsync` 时，代码**不会阻塞**，会立即继续执行下一行。实际的 HTTP 请求可能还没开始发送。

### 2. 底层实现：Handlers 和 cURL Multi

Guzzle 的强大之处在于它的分层设计。实际发送请求的逻辑被抽象成了 **Handler**。默认情况下，Guzzle 使用一个基于 PHP cURL 扩展的 Handler。

这个 Handler 的神奇之处在于它使用了 **`curl_multi_*` 系列函数**。

*   **同步请求 (`request`)**: 当你发送一个同步请求时，Guzzle 的 Handler 会创建一个 cURL 句柄 (`curl_init`)，设置好所有选项，然后调用 `curl_exec()`。程序会**阻塞**在这里，直到这个请求完成，然后返回响应。

*   **异步和并发请求 (`requestAsync`)**: 当你调用 `requestAsync` 时，事情就不同了：
    1.  Guzzle 仍然会创建一个 cURL 句柄，但**不会**立即调用 `curl_exec()`。
    2.  它将这个 cURL 句柄添加到一个 “cURL multi-handle” (`curl_multi_init`) 的集合中。你可以把它看成一个“待处理请求”的篮子。
    3.  你可以多次调用 `requestAsync`，Guzzle 会把所有这些请求的 cURL 句柄都放进这个篮子里。
    4.  到目前为止，还没有一个请求真正被发送出去。

### 3. 触发执行：等待 Promise 完成

当你准备好执行这些请求并等待结果时，你需要“结算”这些 Promises。Guzzle 提供了一些工具函数来做这件事，最常用的是 `Promise\Utils::unwrap()` 或 `Promise\Utils::settle()`。

当你调用 `Utils::unwrap($promises)` 时，Guzzle 的 Handler 才真正开始工作：

1.  它会进入一个循环，反复调用 `curl_multi_exec()`。这个函数是**非阻塞的**。它会检查篮子（multi-handle）里所有请求的状态，处理网络 I/O。
2.  操作系统会在后台处理这些网络连接。PHP 脚本通过 `curl_multi_exec()` 可以同时驱动多个请求的进展。
3.  一旦某个请求完成（或失败），`curl_multi_info_read()` 函数就会报告这个状态。
4.  Guzzle Handler 接收到这个完成信号后，就会找到与这个 cURL 句柄对应的那个 Promise 对象，并将其状态从 `Pending` 修改为 `Fulfilled` (带着响应) 或 `Rejected` (带着异常)。
5.  这个状态的改变会触发你之前通过 `.then()` 注册的回调函数。
6.  `unwrap` 函数会一直阻塞，直到篮子里的**所有** Promises 都被结算（Fulfilled 或 Rejected）。

### 示例：并发获取多个 URL

下面的代码清晰地展示了这个流程：

```php
use GuzzleHttp\Client;
use GuzzleHttp\Promise;

$client = new Client(['base_uri' => 'http://httpbin.org/']);

// 1. 创建多个 Promise，但请求此时并未发送
$promises = [
    'image' => $client->requestAsync('GET', 'image/png'),
    'json'  => $client->requestAsync('GET', 'get'),
    'delay' => $client->requestAsync('GET', 'delay/3'), // 这个请求会耗时3秒
];

echo "Promises created at: " . date('H:i:s') . "\n";

// 2. 使用 unwrap 来等待所有请求完成
// Guzzle 的 Handler 在这一步开始使用 curl_multi_* 并发执行所有请求
$results = Promise\Utils::unwrap($promises);

echo "All responses received at: " . date('H:i:s') . "\n";

// 3. 处理结果
// $results 是一个关联数组，键名与 $promises 相同
echo "Image content type: " . $results['image']->getHeaderLine('Content-Type') . "\n";
echo "JSON data: " . $results['json']->getBody() . "\n";
echo "Delayed response status: " . $results['delay']->getStatusCode() . "\n";
```

**运行结果分析**:

你会发现，从 "Promises created" 到 "All responses received" 的总时间约等于**最慢的那个请求**的时间（这里是 3 秒），而不是所有请求时间的总和。这就是并发带来的效率提升。Guzzle 不是一个一个地等待请求，而是一起发出，然后等待它们全部回来。

### 总结

| 概念 | 作用 |
| :--- | :--- |
| **`requestAsync()`** | 创建一个 Promise（提货单），但**不阻塞**，也不立即发送请求。 |
| **Promise** | 一个代表未来结果的对象，是开发者与异步操作交互的接口。 |
| **Handler** | Guzzle 内部负责实际发送请求的组件，将 Guzzle 的上层 API 与底层实现（如 cURL）解耦。 |
| **`curl_multi_*`** | PHP 的底层 cURL 函数，允许**非阻塞地**处理多个 cURL 连接，是实现 I/O 并发的关键。 |
| **`Promise\Utils::unwrap()`** | 触发所有待定请求的实际执行，并**阻塞**直到所有请求都完成。 |

所以，Guzzle 的异步和并发是**基于 I/O 的并发**，而不是多线程。在任何一个时间点，PHP 仍然是单线程在执行，但它能够高效地管理多个等待网络响应的 I/O 操作，避免了在一个个请求上浪费等待时间。

```php
$promise = $client->requestAsync('GET', 'http://example.com');

$promise->then(
    function ($response) {
        // 请求成功时执行 (Fulfilled)
        echo 'Success! ' . $response->getStatusCode();
    },
    function ($exception) {
        // 请求失败时执行 (Rejected)
        echo 'Error! ' . $exception->getMessage();
    }
);
```

```php
use GuzzleHttp\Client;
use GuzzleHttp\Promise;

$client = new Client(['base_uri' => 'http://httpbin.org/']);

// 1. 创建多个 Promise，但请求此时并未发送
$promises = [
    'image' => $client->requestAsync('GET', 'image/png'),
    'json'  => $client->requestAsync('GET', 'get'),
    'delay' => $client->requestAsync('GET', 'delay/3'), // 这个请求会耗时3秒
];

echo "Promises created at: " . date('H:i:s') . "\n";

// 2. 使用 unwrap 来等待所有请求完成
// Guzzle 的 Handler 在这一步开始使用 curl_multi_* 并发执行所有请求
$results = Promise\Utils::unwrap($promises);

echo "All responses received at: " . date('H:i:s') . "\n";

// 3. 处理结果
// $results 是一个关联数组，键名与 $promises 相同
echo "Image content type: " . $results['image']->getHeaderLine('Content-Type') . "\n";
echo "JSON data: " . $results['json']->getBody() . "\n";
echo "Delayed response status: " . $results['delay']->getStatusCode() . "\n";
```

---

**User**

curl_multi_ 特性在 libcurl 中是否默认可用。

---

**Cursor**

是的，**`curl_multi_*` 特性是 libcurl 库的一个核心且默认可用的功能**。

它并不是一个可选的插件或需要特殊编译标志才能启用的扩展功能。`curl_multi` 接口是 `libcurl` 设计之初就为了解决 **非阻塞 I/O 和并发传输** 问题而提供的两大核心接口之一。

我们可以这样理解 `libcurl` 的接口设计：

1.  **Easy Interface (`curl_easy_*`)**:
    *   这是最常用、最简单的接口，以 `curl_easy_init()`, `curl_easy_perform()`, `curl_easy_setopt()` 等函数为代表。
    *   它的特点是 **阻塞（Blocking）**。当你调用 `curl_easy_perform()` 时，程序会停在那里，直到该单次传输完成（或超时、或失败）。
    *   这个接口非常适合处理单个、同步的网络请求。

2.  **Multi Interface (`curl_multi_*`)**:
    *   这个接口是为了实现 **非阻塞（Non-blocking）** 和 **并发（Parallel）** 传输而设计的，以 `curl_multi_init()`, `curl_multi_add_handle()`, `curl_multi_perform()` 等函数为代表。
    *   它的工作模式是：
        *   创建一个 "multi" 句柄。
        *   创建多个 "easy" 句柄（每一个代表一个独立的传输）。
        *   将所有的 "easy" 句柄添加到 "multi" 句柄中。
        *   在一个循环中反复调用 `curl_multi_perform()`，这个函数会处理所有进行中的传输，但它不会阻塞，会立即返回。
    *   这允许你的应用程序在等待网络 I/O 的同时，去执行其他任务，或者同时管理成百上千个并发连接。

### 在 PHP 环境中的体现

PHP 的 `curl` 扩展（`ext-curl`）是 `libcurl` C 库的一个封装。因此，`libcurl` 的核心功能都被映射到了 PHP 中。

*   只要你的 PHP 环境中安装并启用了 `curl` 扩展，那么 `curl_multi_*` 系列的 PHP 函数（如 `curl_multi_init()`, `curl_multi_add_handle()` 等）就 **必然是可用的**。
*   基本上所有的标准 PHP 发行版、Linux 发行版的 `php-curl` 包、以及主流的托管环境，都会提供完整的 `curl` 扩展支持，其中就包括 `multi` 接口。

一个系统或 PHP 环境中没有 `curl_multi_*` 功能的唯一可能，是有人刻意编译了一个极度精简、移除了该核心功能的 `libcurl` 库，或者在 `php.ini` 的 `disable_functions` 中禁用了它们，但这两种情况都极为罕见。

**总结一下：**

您可以完全放心地认为 `curl_multi_*` 是 `libcurl` 的一个标准、内置、默认可用的特性。像 GuzzleHttp 这样的库也正是基于这个可靠的基础，才能够提供强大的异步和并发请求功能。

